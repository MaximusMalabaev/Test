Наследование
1. Наследование — это процесс, когда один класс наследует атрибуты и методы другого. 
Класс, чьи свойства и методы наследуются, называют Родителем или Суперклассом. 
А класс, свойства которого наследуются — класс-потомок или Подкласс.

Класс-потомок = Свойства и методы родителя + Собственные свойства и методы.
Класс-потомок автоматически наследует от родительского класса все поля и методы.
Класс-потомок может дополняться новыми свойствами.
Класс-потомок может дополняться новыми методами, а также заменять(переопределять) унаследованные методы, это значит, внутри класса потомка есть метод, который совпадает по названию с методом родительского класса, но функционал у него новый - соответствующий потребностям класса-потомка.

Наследование дает возможность использовать код повторно. Классы-потомки берут общий функционал у родительского класса.
Способствует быстрой разработке нового ПО на основе уже существующих открытых классов.
Наследование позволяет делать процесс написания кода более простым.

--------------------------------------------------------------------------------------------------------------------------

Инкапсуляция
2. Инкапсуляция - принцип ООП, согласно которому сложность реализации программного компонента должна быть спрятана за его интерфейсом.
1. Инкапсуляция упрощает процесс разработки, т. к. позволяет нам не вникать в тонкости реализации того или иного объекта.
2. Повышается надежность программ за счет того, что при внесении изменений в один из компонентов, остальные части программы остаются неизменными.
3. Становится более легким обмен компонентами между программами.

Модификаторы:
<имя атрибута>(без одного или двух подчеркиваний вначале)-публичное свойство (public)
<имя атрибута>(c одним подчеркиванием вначале)- режим доступа prorected (можно обращаться только внутри класса и во всех его дочерних классах)
<имя атрибута>(c двумя подчеркиваниями вначале)- режим доступа private (можно обращаться только внутри класса)

Концепция полиморфизма – важная часть ООП на Python. Все методы в языке изначально виртуальные. 
Это значит, что дочерние классы могут их переопределять и решать одну и ту же задачу разными путями, а конкретная реализация будет выбрана только во время исполнения программы. 
Такие классы называют полиморфными.
--------------------------------------------------------------------------------------------------------------------------
Абстракция:
Абстракция - принцип ООП, согласно которому объект характеризуется свойствами, которые отличают его от всех остальных объектов и при этом четко определяют его концептуальные границы.
Т. е. абстракция позволяет:
Выделить главные и наиболее значимые свойства предмета.
Отбросить второстепенные характеристики.

Например, мы должны понимать, что перед нами абстракция, если мы рассматриваем объект как "дом", а не совокупность кирпича, стекла и бетона. А если уже представить множество домов как "город", то мы снова приходим к абстракции, но уже на уровень выше.

Если мыслить масштабно - то она позволяет бороться со сложностью реального мира. Мы отбрасываем все лишнее, чтобы оно нам не мешало, и концентрируемся только на важных чертах объекта.
--------------------------------------------------------------------------------------------------------------------------
Композиция:
Композиция — это объектно-ориентированная концепция дизайна, которая моделирует отношения. В композиции класс, известный как составной, содержит объект другого класса, известный как компонент. Другими словами, составной класс имеет компонент другого класса.

Композиция позволяет составным классам повторно использовать реализацию компонентов, которые она содержит. Составной класс не наследует интерфейс класса компонента, но может использовать его реализацию.

Композиционные отношения между двумя классами считаются слабосвязанными. Это означает, что изменения в классе компонентов редко влияют на составной класс, а изменения в составном классе никогда не влияют на класс компонентов.

ОТЛИЧИЕ НАСЛЕДОВАНИЯ ОТ КОМПОЗИЦИИ:
Композиция более гибкая, чем наследование, потому что она моделирует слабо связанные отношения. Изменения в классе компонентов оказывают минимальное влияние или вообще не влияют на составной класс. Дизайн, основанный на композиции, более подходит для изменений.

Можно изменять поведение, добавляя новые компоненты, которые реализуют это поведение, вместо добавления новых классов в вашу иерархию.

Взгляните на пример множественного наследования выше. Представьте, как новые правила расчета заработной платы повлияют на дизайн. Попробуйте представить, как будет выглядеть иерархия классов, если понадобятся новые роли. Как вы видели раньше, слишком сильная зависимость от наследования может привести к взрыву класса.

Самая большая проблема заключается не столько в количестве классов в дизайне, сколько в том, насколько тесно связаны отношения между этими классами. Сильно связанные классы влияют друг на друга при внесении изменений.

--------------------------------------------------------------------------------------------------------------------------

Итератор:
Итератор (iterator) - это объект, который возвращает свои элементы по одному за раз.

С точки зрения Python - это любой объект, у которого есть метод __next__. Этот метод возвращает следующий элемент, если он есть, или возвращает исключение StopIteration, когда элементы закончились.

Кроме того, итератор запоминает, на каком объекте он остановился в последнюю итерацию.

В Python у каждого итератора присутствует метод __iter__ - то есть, любой итератор является итерируемым объектом. Этот метод просто возвращает сам итератор.

--------------------------------------------------------------------------------------------------------------------------
Генераторы
Генераторы позволяют значительно упростить работу по конструированию итераторов. 
Для построения итератора и работы с ним, мы создаем отдельный класс. 
Генератор – это функция, которая будучи вызванной в функции next() возвращает следующий объект согласно алгоритму ее работы. 
Вместо ключевого слова return в генераторе используется yield.

Отличие от итератора:
Генераторами называют итераторы, определение которых выглядит как определение функций. 
Ещё одно определение: генераторы — функции, которые внутри используют выражение yield. 
!!!Генераторы не могут возвращать значения, вместо этого выдают элементы по готовности.!!!
Python автоматизирует запоминание контекста генератора, то есть текущий поток управления, значение локальных переменных и так далее. Каждый вызов метода __next__ у объекта генератора возвращает следующее значение. Метод __iter__ также реализуется автоматически. 
То есть генераторы можно использовать везде, где требуются итераторы.

--------------------------------------------------------------------------------------------------------------------------

МЕТАКЛАСС (АНГЛ. METACLASS) — В ОБЪЕКТНО-ОРИЕНТИРОВАННОМ ПРОГРАММИРОВАНИИ ЭТО КЛАСС, ЭКЗЕМПЛЯРЫ КОТОРОГО В СВОЮ ОЧЕРЕДЬ ЯВЛЯЮТСЯ КЛАССАМИ.
Проще говоря, в то время как классы являются чертежами для объектов, метаклассы являются чертежами для классов. Класс является описанием, когда мы создаем его экземпляр, тогда как метакласс является описанием класса, и существует только когда определен класс.

Метапрограммирование в Python основано на новом особом типе классов, которые называются метаклассами. Этот тип класса, вкратце, содержит инструкции о закулисной генерации кода, который вы хотите получить, запуская другой код.
Метапрограммирование — вид программирования, связанный с созданием программ, которые порождают другие программы как результат своей работы,
(в частности, на стадии компиляции их исходного кода), либо программ, которые меняют себя во время выполнения (самомодифицирующийся код).
Первое позволяет получать программы при меньших затратах времени и усилий на кодирование, чем если бы программист писал их вручную целиком, второе позволяет улучшить свойства кода (размер и быстродействие).


--------------------------------------------------------------------------------------------------------------------------
Миксины:
В Python так называемые миксины — это классы, которые живут в обычном дереве наследования, но они остаются небольшими, чтобы избежать создания иерархий, которые слишком сложны для понимания программистом. 
В частности, миксины не должны иметь общих предков, кроме объекта, с другими родительскими классами.

--------------------------------------------------------------------------------------------------------------------------
Как создают экземпляр класса(объекта):

В языке программирования Python классы создаются с помощью инструкции class, за которой следует произвольное имя класса, после которого ставится двоеточие, далее с новой строки и с отступом реализуется тело класса:

class ИмяКласса:
    код_тела_класса
Если класс является дочерним, то родительские классы перечисляются в круглых скобках после имени класса.

Объект создается путем вызова класса по его имени. При этом после имени класса обязательно ставятся скобки:

ИмяКласса()
То есть класс вызывается подобно функции. Однако в случае вызова класса происходит не выполнение его тела, как это происходило бы при вызове функции, а создается объект. 
Поскольку в программном коде важно не потерять ссылку на только что созданный объект, то обычно его связывают с переменной. Поэтому создание объекта чаще всего выглядит так:

имя_переменной = ИмяКласса()
В последствии к объекту обращаются через связанную с ним переменную.
--------------------------------------------------------------------------------------------------------------------------
15:
Первый- это синтаксис компановки словаря.

Второе -Генераторное выражение — это выражения, возвращающие итератор генератора.

Некоторые простые генераторы могут быть записаны в виде генераторных выражений, то есть, с использованием синтаксиса, похожего на синтаксис компановки словаря, но не в кавадратных а в круглых скобках.

--------------------------------------------------------------------------------------------------------------------------

16 Grazie

--------------------------------------------------------------------------------------------------------------------------

17. Нельзя получить доступ к атрибутам с двойным подчеркиванием...

--------------------------------------------------------------------------------------------------------------------------

18. Stopiteration